package main

import (
	"flag"
	"os"
	"strings"
	"text/template"
)

type data struct {
	Levels []string
}

func main() {
	funcMap := template.FuncMap{
		"ToLower": strings.ToLower,
	}

	var d data
	var items string
	flag.StringVar(&items, "levels", "", "List of levels")
	flag.Parse()

	if items != "" {
		d.Levels = strings.Split(items, ",")
		// sort.Strings(d.Levels)
	}

	t := template.Must(template.New("queue").Funcs(funcMap).Parse(queueTemplate))
	t.Execute(os.Stdout, d)
}

var queueTemplate = `// Code generated by gen/gen.go - DO NOT EDIT.
package timber

import (
	"fmt"
)

type Keys map[string]interface{}

type Level string

const ({{range $index, $level := .Levels}}
	{{$level}} {{if (eq $index 0)}} Level{{end}} = "{{ $level | ToLower }}"{{end}}
)

type Logger interface {
{{range .Levels}}
	// {{.}} writes the provided string to the log.
	{{.}}(msg string)

	// {{.}}f writes a formatted string using the arguments provided to the log.
	{{.}}f(msg string, args ...interface{})

	// {{.}}Ex writes a formatted string using the arguments provided to the log
	// but also will prefix the log message with they keys provided to help print
	// runtime variables.
	{{.}}Ex(keys Keys, msg string, args ...interface{})
{{end}}
	// Log will write a raw entry to the log, it accepts an array of interfaces which will
	// be converted to strings if they are not already.
	Log(lvl Level, v ...interface{})

	// With will create a new Logger interface that will prefix all log entries written
	// from the new interface with the keys specified here. It will also include any
	// keys that are specified in the current Logger instance.
	// This means that you can chain multiple of these together to add/remove keys that
	// are written with every message.
	With(keys Keys) Logger
}{{range .Levels}}

// {{.}} writes the provided string to the log.
func (l *logger) {{.}}(msg string) {
	l.log(l.stackDepth, {{.}}, nil, msg)
}

// {{.}}f writes a formatted string using the arguments provided to the log.
func (l *logger) {{.}}f(msg string, args ...interface{}) {
	l.log(l.stackDepth, {{.}}, nil, fmt.Sprintf(msg, args...))
}

// {{.}}Ex writes a formatted string using the arguments provided to the log
// but also will prefix the log message with they keys provided to help print
// runtime variables.
func (l *logger) {{.}}Ex(keys Keys, msg string, args ...interface{}) {
	l.log(l.stackDepth, {{.}}, keys, fmt.Sprintf(msg, args...))
}{{else}}
// No levels
{{end}}
`
