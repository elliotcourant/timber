package main

import (
	"flag"
	"os"
	"strings"
	"text/template"
)

type data struct {
	Levels []string
}

func main() {
	funcMap := template.FuncMap{
		"ToLower": strings.ToLower,
	}

	var d data
	var items string
	flag.StringVar(&items, "levels", "", "List of levels")
	flag.Parse()

	if items != "" {
		d.Levels = strings.Split(items, ",")
		// sort.Strings(d.Levels)
	}

	t := template.Must(template.New("queue").Funcs(funcMap).Parse(queueTemplate))
	t.Execute(os.Stdout, d)
}

var queueTemplate = `// Code generated by gen/gen.go - DO NOT EDIT.
// This code can be regenerated by running the go generate below.
//go:generate make generated

package timber

import (
	"fmt"
)

type Keys map[string]interface{}

type Level string

const ({{range $index, $level := .Levels}}
	Level_{{$level}} {{if (eq $index 0)}} Level{{end}} = "{{ $level | ToLower }}"{{end}}
)

type Logger interface {
	loggerBase
{{range .Levels}}
	// {{.}} writes the provided string to the log.
	{{.}}(msg string)

	// {{.}}f writes a formatted string using the arguments provided to the log.
	{{.}}f(msg string, args ...interface{})

	// {{.}}Ex writes a formatted string using the arguments provided to the log
	// but also will prefix the log message with they keys provided to help print
	// runtime variables.
	{{.}}Ex(keys Keys, msg string, args ...interface{})
{{end}}
}{{range .Levels}}

// {{.}} writes the provided string to the log.
func (l *logger) {{.}}(msg string) {
	l.log(l.stackDepth, Level_{{.}}, nil, msg)
}

// {{.}}f writes a formatted string using the arguments provided to the log.
func (l *logger) {{.}}f(msg string, args ...interface{}) {
	l.log(l.stackDepth, Level_{{.}}, nil, fmt.Sprintf(msg, args...))
}

// {{.}}Ex writes a formatted string using the arguments provided to the log
// but also will prefix the log message with they keys provided to help print
// runtime variables.
func (l *logger) {{.}}Ex(keys Keys, msg string, args ...interface{}) {
	l.log(l.stackDepth, Level_{{.}}, keys, fmt.Sprintf(msg, args...))
}{{else}}
// No levels
{{end}}


{{range .Levels}}

// {{.}} writes the provided string to the log.
func {{.}}(msg string) {
	defaultLogger.log(defaultLogger.stackDepth, Level_{{.}}, nil, msg)
}

// {{.}}f writes a formatted string using the arguments provided to the log.
func {{.}}f(msg string, args ...interface{}) {
	defaultLogger.log(defaultLogger.stackDepth, Level_{{.}}, nil, fmt.Sprintf(msg, args...))
}

// {{.}}Ex writes a formatted string using the arguments provided to the log
// but also will prefix the log message with they keys provided to help print
// runtime variables.
func {{.}}Ex(keys Keys, msg string, args ...interface{}) {
	defaultLogger.log(defaultLogger.stackDepth, Level_{{.}}, keys, fmt.Sprintf(msg, args...))
}{{else}}
// No levels
{{end}}`
